package bubbles.specialBubbles;

import entities.Entity;
import levels.Level;
import levels.LevelManager;
import main.Game;
import utilz.Constants.Direction;

import java.awt.*;
import java.awt.image.BufferedImage;

import static utilz.Constants.WaterFLow.*;
import static utilz.Constants.Direction.*;
import static utilz.HelpMethods.*;

public class WaterFlow extends Entity {
    // The water flow object is generated by the water bubble when it pops

    private Level level;
    private boolean firstUpdate = true;
    private Direction direction;
    private Direction previousDirection;

    private long lastTimerUpdate;
    private int drawTimer = WATER_FLOW_DRAW_INTERVAL;
    private int activeTimer = WATER_FLOW_ACTIVE_TIME;

    public WaterFlow(float x, float y, Direction direction) {
        super(x, y, W, H);
        this.direction = direction;
        this.previousDirection = direction;
        this.level = LevelManager.getInstance().getCurrentLevel();

        initHitbox(HITBOX_W, HITBOX_H);
    }

    public void draw(Graphics g) {
//        if (drawTimer > 0)
//            return;

        BufferedImage[][] waterBubbleSprites = SpecialBubbleManager.getInstance().getWaterBubbleSprites();
        g.drawImage(waterBubbleSprites[1][0], (int) (hitbox.x - HITBOX_OFFSET_X), (int) (hitbox.y - HITBOX_OFFSET_Y), W, H, null);
        drawTimer = WATER_FLOW_DRAW_INTERVAL;
        drawHitbox(g);
    }

    public void update() {
        if (firstUpdate) {
            firstUpdate();
            return;
        }

        timerUpdate();
        updateMove();
        pacManEffect();
    }

    private void firstUpdate() {
        //get starting position
        if (IsEntityInsideSolid(hitbox, level.getLevelData())) {
            hitbox.y -= 1;
        }
        else {
            lastTimerUpdate = System.currentTimeMillis();
            firstUpdate = false;
        }
    }

    public void timerUpdate() {
        if (firstUpdate) {
            lastTimerUpdate = System.currentTimeMillis();
            firstUpdate = false;
        }

        long timeDelta = System.currentTimeMillis() - lastTimerUpdate;
        lastTimerUpdate = System.currentTimeMillis();

        drawTimer -= (int) timeDelta;
        activeTimer -= (int) timeDelta;

        if (activeTimer <= 0)
            active = false;
    }

    private void updateMove() {

        if (!IsEntityOnFloor(hitbox, level.getLevelData()))
            direction = DOWN;

        switch (direction) {
            case DOWN -> fall();
            case LEFT -> moveLeft();
            case RIGHT -> moveRight();
        }
    }

    private void fall() {
        float newY = hitbox.y + WATER_FLOW_SPEED;

        if (!IsSolid(hitbox.x, newY + hitbox.width, level.getLevelData()))
            hitbox.y = newY;
        else
            direction = LEFT;
    }

    private void moveLeft() {
        float newX = hitbox.x - WATER_FLOW_SPEED;

        if (!IsSolid(newX, hitbox.y, level.getLevelData()))
            hitbox.x = newX;
        else {
            // change direction
            direction = RIGHT;
            previousDirection = LEFT;
        }
    }

    private void moveRight() {
        float newX = hitbox.x + WATER_FLOW_SPEED;

        if (!IsSolid(newX + hitbox.width, hitbox.y, level.getLevelData()))
            hitbox.x = newX;
        else {
            // change direction
            direction = LEFT;
            previousDirection = RIGHT;
        }
    }

    private void pacManEffect() {
        if (getTileY() == Game.TILES_IN_HEIGHT + 1)
            hitbox.y = -2 * Game.TILES_SIZE;
    }

    public void checkCollisionWithPlayer() {

    }

    public void checkCollisionWithEnemies() {

    }
}
